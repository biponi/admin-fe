implement this to our existing chat/index.tsx and make it 
  fucntional for production use\
  The backend now provides these endpoints compatible with your 
  existing admin
    dashboard:

    Authentication Endpoints

    GET  /api/auth/me              - Get current user info
    POST /api/auth/verify-token    - Verify JWT token validity

    Chat Dashboard Endpoints

    GET  /api/tickets                    - Get tickets with 
  pagination/filters
    GET  /api/tickets/:ticketId          - Get single ticket 
  details
    PATCH /api/tickets/:ticketId/status  - Update ticket status
    PATCH /api/tickets/:ticketId/assign  - Assign ticket to user
    POST /api/tickets/:ticketId/messages - Add message to ticket
    GET  /api/dashboard/stats            - Get dashboard 
  statistics
    GET  /api/dashboard/notifications/summary - Get 
  notifications

    3. Frontend Integration Steps

    A. Token Sharing Setup

    Since both services use the same JWT token, ensure your 
  admin dashboard passes
    the authentication token:

    // In your admin frontend API client
    const apiClient = axios.create({
      baseURL: 'http://localhost:5000/api', // Your chat backend
   URL
      headers: {
        'x-access-token': localStorage.getItem('token'), // 
  Shared token
      }
    });

    B. Update API Calls in Chat Component

    Modify your existing chat component to use the new backend 
  endpoints:

    // Replace existing API calls with:
    const fetchTickets = async (filters = {}) => {
      const response = await apiClient.get('/tickets', { params:
   filters });
      return response.data;
    };

    const sendMessage = async (ticketId: string, content: 
  string) => {
      const response = await 
  apiClient.post(`/tickets/${ticketId}/messages`, {
        content,
        sender: 'agent',
        senderId: currentUser.id,
        messageType: 'text'
      });
      return response.data;
    };

    const updateTicketStatus = async (ticketId: string, status: 
  string) => {
      const response = await 
  apiClient.patch(`/tickets/${ticketId}/status`, {
        status
      });
      return response.data;
    };

    C. Socket.IO Integration

    Add real-time functionality to your chat component:

    import { io, Socket } from 'socket.io-client';

    const socket: Socket = io('http://localhost:5000/agent', {
      auth: {
        token: localStorage.getItem('token')
      }
    });

    // Listen for new messages
    socket.on('customer_message', (data) => {
      // Update your chat UI with new customer message
      updateChatMessages(data);
    });

    // Send agent messages
    const sendAgentMessage = (ticketId: string, content: string)
   => {
      socket.emit('send_message', {
        ticketId,
        content,
        messageType: 'text'
      });
    };

    4. Permission Integration

    The backend now uses your existing permission system. Ensure
   users have
    appropriate Chat permissions:

    // Your existing permission check function works with the 
  backend
    const canReply = hasPagePermission("Chat", "reply", 
  userPermissions);
    const canAttend = hasPagePermission("Chat", "attend", 
  userPermissions);
    const canManage = hasPagePermission("Chat", "manage", 
  userPermissions);

    5. Data Structure Compatibility

    The backend returns data in a format compatible with your 
  frontend. Key
    interfaces:

    interface Ticket {
      _id: string;
      ticketId: string;
      customerId: string;
      customerInfo: {
        name: string;
        email?: string;
        phone?: string;
      };
      subject: string;
      status: 'open' | 'assigned' | 'pending' | 'resolved' | 
  'closed';
      priority: 'low' | 'normal' | 'high' | 'urgent';
      department: string;
      assignedAgent?: string; // User ID
      messages: Message[];
      createdAt: Date;
      updatedAt: Date;
    }

    interface Message {
      _id: string;
      content: string;
      sender: 'customer' | 'agent';
      senderId: string;
      messageType: 'text' | 'image' | 'file';
      timestamp: Date;
      read: boolean;
    }

    6. Deployment Considerations

    A. Development Setup

    1. Start biponi-express server on port 8000
    2. Start chat backend on port 5000
    3. Both services share the same TOKEN_KEY
    4. Admin frontend connects to both services

    B. Production Setup

    1. Deploy chat backend as a separate microservice
    2. Configure load balancer to route /api/chat/* to chat 
  service
    3. Ensure both services use the same JWT secret
    4. Configure CORS properly for your domain

    7. Migration Steps

    1. Backend: The authentication integration is complete
    2. Frontend: Update your chat component API calls to use the
   new endpoints
    3. Testing: Verify token sharing works between services
    4. Deployment: Deploy chat backend alongside existing 
  infrastructure

    8. Key Benefits

    - Seamless Authentication: Users don't need to login again
    - Permission Integration: Existing role-based permissions 
  work
    - Real-time Chat: Socket.IO for instant message updates
    - Meta Messenger: Integrated Facebook Messenger support
    - Scalable Architecture: Microservice design for independent
   scaling